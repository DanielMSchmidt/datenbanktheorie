\documentclass[12pt,a4paper]{amsart}

\synctex = 1

\input{alphabets}
\input{commands}
\input{environments}

\usepackage{amsmath,amsthm,amssymb}
\usepackage[utf8]{inputenc}
\usepackage{wasysym}
\usepackage{stmaryrd}
\usepackage{nicefrac}
\usepackage{listings}
\usepackage{pictex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{german}

\lstset{basicstyle=\small}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Blatt 9}

\author{Daniel Schmidt \& Pamela Fleischmann}

\maketitle

\begin{aufgabe1}
Um zu zeigen, dass Datalog ohne Rekursion, aber mit Negation und sicheren Regeln die gleiche Ausdruckskraft wie die Relationenalgebra hat muss gezeigt werden, dass $\mu(L) = \mu'(L')$ gilt, wobei Datalog als $(L, \mu)$ definiert ist und die Relationenalgebra $(L', \mu')$ ist.
Hierzu gilt zu zeigen, dass dies für ein beliebiges Datenbankschema $\sigma$ gilt.
Also müssen folgende Aussagen gezeigt werden:

\begin{align*}
1) &\forall e' \in L': \exists e \in L: \mu'(e') = \mu(e) \\
2) &\forall e \in L: \exists e' \in L': \mu(e) = \mu'(e')
\end{align*}

Diese werden nun einzelnd gezeigt:

\paragraph{1)}

Um zu zeigen, dass jeder Ausdruck der in der Relationenalgebra in einen bedeutungsgleichen Ausdruck in Datalog umgeformt werden kann muss lediglich gezeigt werden, dass die einzelnen Konzepte jeweils ausgedrückt werden können. Die Zusammensetzung dieser ist implizit durch die Zusammensetzbarkeit der Ausdrücke gegeben. Seien $e_{Rel}$ und $e_{Rel}'$ im Folgenden Ausdrücke der Relationenalgebra; Seien $e_{Dat}$ und $e_{Dat}'$ bereits überführte Datalog Regeln und $e_{Dat}''$ die durch die Umformung entstehende Regel. \\

\paragraph{\textbf{Selektion}}
Sei $e_{Rel} = e_{Rel}'[es_1, \cdots, es_n]$ mit $n > 0$ und $es_i$ Vergleichsausdrücke mit $0 < i \le n$.
Dann lässt sich $e$ in Datalog als $e_{Dat}''(V) :- e_{Dat}'(V), es_1(V), \cdots, es_n(V)$ ausdrücken, wobei V die Liste der Argumente, bzw. die Spalten der Tabelle sind; Beide Aussagen sind äquivalent. \\

\paragraph{\textbf{Umbenennung}}
Sei $V$ die Liste aller Spalten in $e_{Rel}$ und $V'$ die Liste aller Spalten in $e_{Rel}[k \rightarrow j]$, so gilt $k \in V \wedge k \not \in V' \wedge j \not \in V \wedge j \in V'$. Dann lässt sich die Umbenennung darstellen als $e_{Dat}''(V) :- e_{Dat}(V').$. \\

\paragraph{\textbf{Projektion}}
Eine Projektion lässt sich analog zur Umbenennung umsetzen, allerdings muss hierbei die Menge $V'$ so gewählt werden, dass jedes $k \in V$ durch ein $``\_''$ ersetzt wird das nicht in der Menge der erlaubten Felder enthalten ist. \\

\paragraph{\textbf{Kartesisches Produkt}}
Sei der Ausdruck $e''_{Rel} = e_{Rel} \times e_{Rel}'$ gegeben. 
Seien die Parameter $Param_{e_{Rel}}, Param_{e_{Rel}'}, Param_{e_{Rel}''}$ wie folgt definiert: \\
Sei $Param_{e_{Rel}}$ gegeben als alle Spalten im Resultat von $e$ und $Param_{e_{Rel}'}$ als allen Spalten im Resultat von $e'$. Dann ist $Param_{e_{Rel}''}$ zu definieren als Liste von Parametern $x_1, \cdots x_n, y_1, \cdots, y_m$ mit $n = |Param_{e_{Rel}}|, \quad m = |Param_{e_{Rel}'}|, \quad x_i \in Param_{e_{Rel}} \text { für } 1 \le i \le n, \quad y_i \in Param_{e_{Rel}'} \text { für } 1 \le i \le m$. \\
In Prolog lässt sich das kartesische Produkt dann durch \\ $e_{Dat}''(Param_{e''}) :- e_{Dat}(Param_{e})), e_{Dat}'(Param_{e'}))$ ausdrücken. \\

\paragraph{\textbf{Differenz}}
Sei der Ausdruck $e''_{Rel} = e_{Rel} \backslash e_{Rel}'$ gegeben. Sei der Parameter $Param_{e_{Rel}}$ definiert als alle Spalten im Resultat von $e_{Rel}$, \footnote{Äquivalent zu allen Spalten im Resultat von $e_{Rel}'$ und allen Ergebnisspalten} so lässt sich die Differenz definieren als Regel \\

\begin{lstlisting}[escapeinside={(*}{*)}]
(*$e_{Dat}''(Param_e)$*) :- (*$e(Param_e)$*), not (*$e'(Param_e)$*).
\end{lstlisting}

\paragraph{\textbf{Vereinigung}}
Sei der Ausdruck $e''_{Rel} = e_{Rel} \cup e_{Rel}'$ gegeben und V die Liste aller Spalten in $e_{Rel}$ und damit auch in $e_{Rel}'$, so ist die äquivale Datalog Regel gegeben als:

\begin{lstlisting}[escapeinside={(*}{*)}]
(*$e_{Dat}''$*)(V) :- (*$e_{Dat}'(V)$*).
(*$e_{Dat}''$*)(V) :- (*$e_{Dat}(V)$*).
\end{lstlisting}

Weitere Operationen müssen nach Satz 2.1 nicht gezeigt werden, daher ist diese Richtung ausreichend bewiesen.

\paragraph{2)}

Analog zu 1) muss gezeigt werden, dass es zu jeder Operation in Datalog eine äquivalente in der Relationenalgebra gibt. Hierzu seien $e_{Dat}$ und $e_{Dat}'$ im Folgenden Ausdrücke in Datalog; Seien $e_{Rel}$ und $e_{Rel}'$ bereits überführte Ausdrücke der Relationenalgebra und $e_{Rel}''$ der durch die Umformung entstehende Ausdruck. \\


\paragraph{\textbf{Fakt}}
Fakten in Datalog lassen sich über das Konzept des Datenbankzustands in der Relationenalgebra abbilden, ist ein Fakt gegeben, so ist ein Eintrag in der entsprechenden Datenbanktabelle gegeben.\\

\paragraph{\textbf{Und}}
Wie in Teil 1) zu sehen wird ``und'' bei diversen Operationen benötigt, somit sind auf der Rückrichtung ebenfalls diverse Fälle möglich. Hierbei lässt es sich am einfachsten anhand der Parametermenge $V$ von $e_{Dat}$ und $V'$ von $e_{Dat}'$ in der Regel $e_{Dat}'' :- e_{Dat}, e_{Dat}'$ unterscheiden:

\begin{enumerate}
\item $V = V'$: In diesem Fall handelt es sich um einen Schnitt von $e_{Rel}$ udn $e_{Rel}'$ in der Relationenalgebra.
\item $V \cap V' = \emptyset$: Da beide Mengen disjunkt sind handelt es sich um ein kartesisches Produkt in der Relationenalgebra, was wie in 1) gezeigt eine äquivalente Darstellung ist.
\item sonst: Da beide Mengen weder gleich noch disjunkt sind handelt es sich um ein Join, welches wie bereits gezeigt durch ein kartesisches Produkt und eine Selektion dargestellt werden kann.
\end{enumerate}

\paragraph{\textbf{Oder}}
Dies wurde bereits unter 1) - Vereinigung gezeigt.

\paragraph{\textbf{Geänderte Variablenbezeichnungen im Regelkopf}}
Dies wurde bereits unter 1) - Umbenennung, Projektion gezeigt.

\paragraph{\textbf{Vergleichsausdrücke}}
Dies wurde bereits unter 1) - Selektion gezeigt. 

\paragraph{\textbf{Not}}
% Bin mir hier unsicher
Not lässt sich danke Closed World Assumption umschreiben als $(Tab_e \backslash e)[V]$, wobei $Tab_e$ das kartesische Produkt aller in e vorkommenden extensionale Prädikate beschreibt und $V$ die im Regelkopf von e verwendeten Variablen.

\end{aufgabe1}


\begin{aufgabe1}
ad. a)

Die äquivalente Darstellung in Prolog ist

\begin{lstlisting}
a(A,B) :- R(A,B,_).
a(A,B) :- S(A,D), T(_,D,B).
\end{lstlisting}

ad. b)

Die äquivalente Darstellung in Prolog ist


\begin{lstlisting}
sbt(A,B,C,G) :- S(A,C), T(B,C,G).
r'(A,B,C) :- R(A,B,C), A > B.
r'(A,B,C) :- R(A,B,C), C > 5.
rbs(A,B,C,G) :- r'(A,B,C), S(A,G).
q(A,B,C,G) :- sbt(A,B,C,G), not rbs(A,B,C,G).
\end{lstlisting}
\end{aufgabe1}

\begin{aufgabe1}
\end{aufgabe1}

\end{document}
