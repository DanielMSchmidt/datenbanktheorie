\documentclass[12pt,a4paper]{amsart}

\synctex = 1

\input{alphabets}
\input{commands}
\input{environments}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\pr}{pr}

\usepackage{amsmath,amsthm,amssymb}
\usepackage[utf8]{inputenc}
\usepackage{wasysym}
\usepackage{stmaryrd}
\usepackage{nicefrac}
\usepackage{listings}
\usepackage{pictex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{german}

\lstset{basicstyle=\small}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Blatt 10}

\author{Daniel Schmidt \& Pamela Fleischmann}

\maketitle

\begin{aufgabe1}
Um zu zeigen, dass sich für jede TRC-Anfrage zu einem DB-Schema $\sigma$ eine äquivalente Anfrage des DRC zu $\sigma$ finden lässt definieren wir uns einen Algorithmus, welcher TRC-Anfragen zu DRC-Anfragen umformt.
Sei also eine allgemeine TRC-Anfrage $(x) / \theta(x)$, so lässt sich der Algorithmus wie folgt beschreiben: \\
Sei zunächst für jede Variable $k$ in $x$ mit dem Typen $\tau_1, \cdots, \tau_n$ neue Variablen $k_1, \cdots, k_n$ mit den entsprechenden Typen eingeführt. Nun gilt es die Variablen zu ersetzen um DRC-Anfragen zu erhalten, dies geschieht nach den folgenden Regeln: \\
Wenn $RT_i(k)$ gegeben ist, so muss dies durch $RT_i(k_1, \cdots, k_n)$ ersetzt werden.
Falls $k.B_j \theta c(c \theta k.B_j)$ gegeben ist, so muss dies durch $k_j \theta c(c \theta k_j)$ ersetzt werden.
Wenn $k.B_j \theta z.C_h$ gegeben ist, so muss dies ersetzt werden durch $k_j \theta z_h$. \\
Falls $\exists k$ gegeben ist, so muss dies falls $k$ gebunden ist durch $(\exists k_1), \cdots, (\exists k_n)$ ersetzt werden. Falls $k$ ungebunden ist, so ist dies nicht nötig, da das Ergbnis ohnehin nicht weiterverwendet wird.
Analog lässt sich $\forall k$ umformen.
Zuguterletzt muss die Zielfunktion noch angepasst werden, entprechend also $(x) / \cdots$ zu $(x_1, \cdots, x_n) / \cdots$ umgeformt werden.
\end{aufgabe1}

\begin{aufgabe1}
Die Idee für $\rank(e)$ ist in einer while-Schleife eine Variable hochzuzählen während von der Originalrelation die Stellen sukzessive abgeschnitten werden:
\begin{align*}
\begin{split}
&y=E\downarrow\downarrow\uparrow \mbox{// Darstellung von 1}\\
&x=e\\
&\mbox{while }x\mbox{ do }(x=x\downarrow;y=y\uparrow)
\end{split}
\end{align*}
Für die Projektion auf die $i$-te Komponente einer Relation $r_i$ sei $e$ die Darstellung von $\rank(r_i)-i$ und $e''$ die Darstellud von $i-1$. 
\begin{align*}
\begin{split}
&x=e; \\
&y=r_i; \\
&\mbox{while }x\neq\emptyset\mbox{ do }(y=y'\downarrow;x=x\downarrow)\\
&x=e'';\\
&\mbox{while }x\neq\emptyset\mbox{ do }(y=y\circlearrowleft;y=y\downarrow;x=x\downarrow;)
\end{split}
\end{align*}
Die Idee ist die hinteren Stellen abzuschneiden und dann immer zu permutieren und abzuschneiden, bis nur noch die richtige Stelle übrig ist.

\medskip

Definiere $\uparrow_d:\mathcal{R}_s\rightarrow\mathcal{R}_s;e\mapsto\{(d_1,\dots,d_s,d)\}|(d_1,\dots,d_s)\in e\}$ (wir haben diesen Operator leider nicht modelliert bekommen).
Das kartesische Produkt ist gegeben durch
\begin{align*}
\begin{split}
&x=\rank(e);\\
&\mbox{while }x\neq\emptyset\mbox{ do }(e=e\uparrow_{\pr_x(e_2)};x=x\downarrow)
\end{split}
\end{align*}
 Ist $r_2$ eine Relation, die auf die zu projizierenden Indizes vorhält, so ergibt sich die allgemeine Projektion durch
 \begin{align*}
 \begin{split}
 &y=r_2\\
 &x=\rank(r_1)\\
 &\mbox{while }y\neq\emptyset\mbox{ do }(\mbox{while }x\neq\emptyset\mbox{ do }(\mbox{if }(x,y)\in E \mbox{ then }e_1=e_1\times \pr_y(e))))
 \end{split}
 \end{align*}
Das Anfügen von Elementen von links ist definiert durch
\begin{align*}
\begin{split}
E\downarrow\times e;
\end{split}
\end{align*}
\end{aufgabe1}

\end{document}
